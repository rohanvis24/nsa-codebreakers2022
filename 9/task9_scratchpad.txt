Possible methodology:
Run the program, but replace the outcome of time.Now() with the timestamp of when the key was generated
Then, break at the call when the decrypter is created to get the exact IV used to ultimately decrypt the key and find out what the 8 starting bytes are meant to be
-------------------------------------------------------------
AnimatedTolerant hashes:
eb0b95afd5fc68a5e77bcb0e2d057600 - goal hash
	49737
cf335c1132965b31727160df1c0bf808
	25435






49737|Yk+ng/q3jXJ92WKxKdRa/XEh4pXqAeiBLwe+/yWj6gqQc2qOJOiCeTRhrdDhqoLLb3opeVSzlz6NV1wUolyUHw==|2.296|AnimatedTolerant|2021-01-11T05:01:45-05:00
goal hash: eb0b95afd5fc68a5e77bcb0e2d057600
trying marshal: {"cid":49737,"demand amount":2.296,"username":"AnimatedTolerant"}
trying marshal: {"plainKey":"0258380f-53f4-11eb-9311-24276e22","result":"ok"}

IV for each key is the random 8 bytes at the start of each key. im dumb and kept wondering what that crypto.randread was... *facepalm*

OKAY so now we can decrypt funny keys. It's UUIDv1 timestamps of the time the keys were generated (without 2 trailing \x00 bytes). The last 3 blocks are constant since they all originate from the same computer. From task 2, we know the time that the tools were downloaded onto the machine, so we can use that as a start time to try and brute force the key to decrypt our pdf :)

Tools was downloaded at Jun  8, 2022 03:08:36.586149000 Central Daylight Time
By trial and error, this UUID is pretty close: 2fffa000-e702-11ec-af6f-0800200c9a66 -> 2022-06-08 08:08:32.287539.2 UTC

Now we change the ending 3 blocks to match those in the database:  2fffa000-e702-11ec-9311-24276e22
We can increment the first byte and try to decrypt the encrypted pdf with each key
